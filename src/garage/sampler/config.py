"""Class for configuring a Sampler."""

from collections import defaultdict

import numpy as np
import psutil

from garage.experiment import deterministic


def rollout(config, worker_number, agent, env, max_path_length):
    """Sample a single rollout of the agent in the environment.

    Args:
        config(SamplerConfig): The config this function is stored in. This
            argument is ignored, but present to match the API set by
            `SamplerConfig`.
        worker_number(int): The worker number this rollout is being performed
            in. Returned as the first return value.
        agent(Policy): Agent used to select actions.
        env(gym.Env): Environment to perform actions in.
        max_path_length(int): If the rollout reaches this many timesteps, it is
            terminated.

    Returns:
        worker_number(int): The worker number passed into this function.
        observations(np.array): Non-flattened array of observations.
        actions(np.array): Non-flattened array of actions.
        rewards(np.array): Array of rewards of shape (timesteps, 1).
        agent_infos(dict[str, np.array]): Dictionary of stacked, non-flattened
            `agent_info`s.
        env_infos(dict[str, np.array]): Dictionary of stacked, non-flattened
            `env_info`s.

    """
    observations = []
    actions = []
    rewards = []
    agent_infos = defaultdict(list)
    env_infos = defaultdict(list)
    o = env.reset()
    agent.reset()
    next_o = None
    path_length = 0
    while path_length < max_path_length:
        a, agent_info = agent.get_action(o)
        next_o, r, d, env_info = env.step(a)
        observations.append(o)
        rewards.append(r)
        actions.append(a)
        for k, v in agent_info.items():
            agent_infos[k].append(v)
        for k, v in env_info.items():
            env_infos[k].append(v)
        path_length += 1
        if d:
            break
        o = next_o
    for k, v in agent_infos.items():
        agent_infos[k] = np.asarray(v)
    for k, v in env_infos.items():
        env_infos[k] = np.asarray(v)
    return (worker_number, np.array(observations), np.array(actions),
            np.array(rewards), dict(agent_infos), dict(env_infos))


def default_env_update_fn(config, worker_number, env, env_update):
    """Use any non-None env_update as a new environment.

    A simple env update function. If env_update is not None, it should be the
    complete new environment. Otherwise, the old environment is returned.

    This allows changing environments by passing the new environment as
    `env_update` into `obtain_samples`.

    Args:
        config(SamplerConfig): The config this function is stored in. This
            argument is ignored, but present to match the API set by
            `SamplerConfig`.
        worker_number(int): The number of the worker this update is occurring
            in. This argument is ignored, but present to match the API set by
            `SamplerConfig`.
        env(gym.Env): The environment to update.
        env_update(gym.Env or None): The environment to replace it with.

    Returns:
        The updated environment.

    """
    if env_update is not None:
        return env_update
    else:
        return env


def default_agent_update_fn(config, worker_number, agent, agent_update):
    """Update an agent, assuming it implements garage.tf.policies.Policy2.

    Args:
        config(SamplerConfig): The config this function is stored in. This
            argument is ignored, but present to match the API set by
            `SamplerConfig`.
        worker_number(int): The number of the worker this update is occurring
            in. This argument is ignored, but present to match the API set by
            `SamplerConfig`.
        agent(garage.tf.policies.Policy2): The agent to update.
        agent_update(dict[str, np.array]): Parameters to agent, which should
            have been generated by calling `policy.get_param_values`.

    Returns:
        The updated agent.

    """
    agent.set_param_values(agent_update)
    return agent


def default_worker_init_fn(config, worker_number):
    """Initialize a worker.

    Args:
        worker_number(int): The number of the worker this update is occurring
            in. This argument is used to set a different seed for each worker.
        config(SamplerConfig): The config this function is stored in. Used to
            get the main seed, on which all other seeds used by the sampler are
            based.

    """
    deterministic.set_seed(config.seed + worker_number)


def identity_function(x):
    """Do nothing.

    This function can exists so it can be pickled.
    """
    return x


class SamplerConfig:
    """An object for configuring the sampler.

    The intent is that this object should be sufficient to avoid subclassing
    the sampler. Instead of subclassing the sampler for e.g. a specific
    backend, implement a specialized SamplerConfig (or specify appropriate
    functions to this one). Not that this object must be picklable, since it
    may be passed to workers. However, its fields individually need not be.

    All arguments to this type must be passed by keyword.

    Args:
        seed(int): The seed to use to intialize random number generators.
        n_workers(int): The number of workers to use.
        max_path_length(int): The maximum length paths which will be sampled.
        worker_init_fn((int, SamplerConfig) -> None): Function to run in
            workers before constructing any agents or environments in them.
            The first argument should be the worker number, and the second
            argument should be this config.
        env_update_fn((int, gym.Env, object) -> gym.Env): Function to run to
            update the environment before rollouts begin in each
            `obtain_samples` call. Its arguments are the worker number, the
            current environment, and the environment update passed into
            `obtain_samples` (which defaults to `None`). It should return the
            new environment (which may also be the old environment).
        agent_update_fn((int, garage.Policy, object) -> garage.Policy):
            Function to run to update the agent before rollouts begin in each
            `obtain_samples` call. Its arguments are the worker number, the
            current agent, and the agent update passed into `obtain_samples`.
            It should return the new agent (which may also be the old agent).

    """

    def __init__(
            self,
            *,  # Require passing by keyword.
            seed,
            n_workers=psutil.cpu_count(logical=False),
            max_path_length,
            worker_init_fn=default_worker_init_fn,
            agent_update_fn=default_agent_update_fn,
            env_update_fn=default_env_update_fn,
            rollout_fn=rollout):
        self.seed = seed
        self.n_workers = n_workers
        self.max_path_length = max_path_length
        self.worker_init_fn = worker_init_fn
        self.env_update_fn = env_update_fn
        self.agent_update_fn = agent_update_fn
        self.rollout_fn = rollout_fn

    def get_worker_broadcast(self, objs, preprocess=identity_function):
        """Take an argument and canonicalize it into a list for all workers.

        This helper function is used to handle arguments in the sampler API
        which may (optionally) be lists. Specifically, these are agent, env,
        agent_update, and env_update. Checks that the number of parameters is
        correct.

        Args:
            objs(object or list): Must be either a single object or a list
                of length self.n_workers.
            preprocess(function): Function to call on each single object before
                creating the list.

        Returns:
            list[object]: A list of length self.n_workers.

        """
        if isinstance(objs, list):
            print('objs', objs)
            if len(objs) != self.n_workers:
                raise ValueError(
                    "Length of list doesn't match number of workers")
            return [preprocess(obj) for obj in objs]
        else:
            obj = preprocess(objs)
            return [obj for _ in range(self.n_workers)]
